
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/_rendered_examples/dynamo/refit_engine_example.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials__rendered_examples_dynamo_refit_engine_example.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials__rendered_examples_dynamo_refit_engine_example.py:


.. _refit_engine_example:

Refit  TenorRT Graph Module with Torch-TensorRT
===================================================================

We are going to demonstrate how a compiled TensorRT Graph Module can be refitted with updated weights.

In many cases, we frequently update the weights of models, such as applying various LoRA to Stable Diffusion or constant A/B testing of AI products.
That poses challenges for TensorRT inference optimizations, as compiling the TensorRT engines takes significant time, making repetitive compilation highly inefficient.
Torch-TensorRT supports refitting TensorRT graph modules without re-compiling the engine, considerably accelerating the workflow.

In this tutorial, we are going to walk through
1. Compiling a PyTorch model to a TensorRT Graph Module
2. Save and load a graph module
3. Refit the graph module

.. GENERATED FROM PYTHON SOURCE LINES 20-22

Standard Workflow
-----------------------------

.. GENERATED FROM PYTHON SOURCE LINES 24-26

Imports and model definition
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 26-38

.. code-block:: python


    import numpy as np
    import torch
    import torch_tensorrt as torch_trt
    import torchvision.models as models
    from torch_tensorrt.dynamo import refit_module_weights

    np.random.seed(0)
    torch.manual_seed(0)
    inputs = [torch.rand((1, 3, 224, 224)).to("cuda")]



.. GENERATED FROM PYTHON SOURCE LINES 39-41

Compile the module for the first time and save it.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 41-66

.. code-block:: python


    model = models.resnet18(pretrained=False).eval().to("cuda")
    exp_program = torch.export.export(model, tuple(inputs))
    enabled_precisions = {torch.float}
    debug = False
    workspace_size = 20 << 30
    min_block_size = 0
    use_python_runtime = False
    torch_executed_ops = {}
    trt_gm = torch_trt.dynamo.compile(
        exp_program,
        tuple(inputs),
        use_python_runtime=use_python_runtime,
        enabled_precisions=enabled_precisions,
        debug=debug,
        min_block_size=min_block_size,
        torch_executed_ops=torch_executed_ops,
        make_refitable=True,
    )  # Output is a torch.fx.GraphModule

    # Save the graph module as an exported program
    # This is only supported when use_python_runtime = False
    torch_trt.save(trt_gm, "./compiled.ep", inputs=inputs)



.. GENERATED FROM PYTHON SOURCE LINES 67-69

Refit the module with update model weights
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 69-93

.. code-block:: python


    # Create and compile the updated model
    model2 = models.resnet18(pretrained=True).eval().to("cuda")
    exp_program2 = torch.export.export(model2, tuple(inputs))


    compiled_trt_ep = torch_trt.load("./compiled.ep")

    # This returns a new module with updated weights
    new_trt_gm = refit_module_weights(
        compiled_module=compiled_trt_ep,
        new_weight_module=exp_program2,
        arg_inputs=inputs,
    )

    # Check the output
    expected_outputs, refitted_outputs = exp_program2.module()(*inputs), new_trt_gm(*inputs)
    for expected_output, refitted_output in zip(expected_outputs, refitted_outputs):
        assert torch.allclose(
            expected_output, refitted_output, 1e-2, 1e-2
        ), "Refit Result is not correct. Refit failed"

    print("Refit successfully!")


.. GENERATED FROM PYTHON SOURCE LINES 94-96

Alternative Workflow using Python Runtime
-----------------------------

.. GENERATED FROM PYTHON SOURCE LINES 96-99

.. code-block:: python


    # Currently python runtime does not support engine serialization. So the refitting will be done in the same runtime.
    # This usecase is more useful when you need to switch different weights in the same runtime, such as using Stable Diffusion.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.000 seconds)


.. _sphx_glr_download_tutorials__rendered_examples_dynamo_refit_engine_example.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: refit_engine_example.py <refit_engine_example.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: refit_engine_example.ipynb <refit_engine_example.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
